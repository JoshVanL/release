package helm

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"strings"

	"github.com/google/go-github/v35/github"
	"github.com/pkg/errors"
	utilerrors "k8s.io/apimachinery/pkg/util/errors"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/utils/pointer"

	"github.com/cert-manager/release/pkg/release/manifests"
)

const (
	// Some template strings for GitHub commit and PR messages.
	tplCommitMessage = "Add %s"
	tplPRTitle       = "Helm charts for cert-manager staged release: %s"
	tplPRDescription = "This PR was generated by [cmrel](https://github.com/cert-manager/release) for the cert-manager staged release: `%s`."
)

var acceptableGitHubPermissions sets.String

func init() {
	acceptableGitHubPermissions = sets.NewString("write", "admin")
}

type RepositoryManager interface {
	// Check is called immediately after instantiating the RepositoryManager to
	// verify that the supplied GitHub configuration is valid and that the
	// supplied GitHub client has permissions to perform branching, uploading
	// and creating PRs.
	Check(ctx context.Context) error
	// Publish creates a new GitHub branch, uploads all the chart files and then
	// creates a PR to merge those into the main branch for the repository.
	// The PR URl is returned on success.
	Publish(ctx context.Context, releaseName string, charts ...manifests.Chart) (prURL string, err error)
}

type gitHubRepositoryManager struct {
	*GitHubClient
	owner  string
	repo   string
	branch string
}

// NewGitHubRepositoryManager returns a gitHubRepositoryManager which implements
// RepositoryManager to upload Helm charts to a branch in a GitHub repository
// and create a PR.
func NewGitHubRepositoryManager(client *GitHubClient, owner, repo, branch string) RepositoryManager {
	return &gitHubRepositoryManager{
		GitHubClient: client,
		owner:        owner,
		repo:         repo,
		branch:       branch,
	}
}

// Check is documented at RepositoryManager.Check
// Requests the user associated with the current Oauth token and checks whether
// that user has write permission to the configured repository and whether it
// has the repo scope.
func (o *gitHubRepositoryManager) Check(ctx context.Context) error {
	var errs []error

	// NB: Empty user means current logged in user
	user, _, err := o.UsersClient.Get(ctx, "")
	if err != nil {
		return err
	}

	perm, response, err := o.RepositoriesClient.GetPermissionLevel(ctx, o.owner, o.repo, user.GetLogin())
	if err != nil {
		return err
	}

	scopes := response.Header.Get("X-Oauth-Scopes")
	if scopes != string(github.ScopeRepo) {
		errs = append(errs, fmt.Errorf("expected scope %q, got %q", github.ScopeRepo, scopes))
	}

	actualPermission := perm.GetPermission()
	if !acceptableGitHubPermissions.Has(actualPermission) {
		errs = append(
			errs,
			fmt.Errorf(
				"expected permission to be one of %q, got: %q",
				strings.Join(acceptableGitHubPermissions.List(), ","),
				actualPermission,
			),
		)
	}

	return utilerrors.NewAggregate(errs)
}

// Publish is documented at RepositoryManager.Publish
func (o *gitHubRepositoryManager) Publish(ctx context.Context, releaseName string, charts ...manifests.Chart) (string, error) {
	log.Printf("Creating PR for merging Helm charts of %q into %q", releaseName, o.destination())

	// Create a new branch
	newBranchName := releaseName
	if err := o.createBranch(ctx, o.branch, newBranchName); err != nil {
		return "", err
	}

	// Upload charts
	for _, chart := range charts {
		if err := o.commitChartToBranch(ctx, newBranchName, chart); err != nil {
			return "", err
		}
	}
	// Create PR
	npr := &github.NewPullRequest{
		Title: pointer.StringPtr(fmt.Sprintf(tplPRTitle, releaseName)),
		Body:  pointer.StringPtr(fmt.Sprintf(tplPRDescription, releaseName)),
		Base:  pointer.StringPtr(o.branch),
		Head:  pointer.StringPtr(newBranchName),
	}
	pr, _, err := o.PullRequestClient.Create(ctx, o.owner, o.repo, npr)
	if err != nil {
		return "", errors.WithStack(err)
	}
	prURL := pr.GetHTMLURL()
	log.Printf("Created PR: %s ", prURL)
	return prURL, nil
}

// createBranch creates a new branch on the target repo
// See https://stackoverflow.com/questions/9506181/github-api-create-branch
func (o *gitHubRepositoryManager) createBranch(ctx context.Context, sourceName, branchName string) error {
	source, _, err := o.GitClient.GetRef(ctx, o.owner, o.repo, fmt.Sprintf("refs/heads/%s", sourceName))
	if err != nil {
		return errors.WithStack(err)
	}
	ref := &github.Reference{
		Ref:    pointer.StringPtr(fmt.Sprintf("refs/heads/%s", branchName)),
		Object: source.GetObject(),
	}
	_, _, err = o.GitClient.CreateRef(ctx, o.owner, o.repo, ref)
	return errors.WithStack(err)
}

// commitChartToBranch uploads a single Helm chart to the target branch.
func (o *gitHubRepositoryManager) commitChartToBranch(ctx context.Context, branch string, chart manifests.Chart) error {
	chartFileName := chart.PackageFileName()
	chartContent, err := ioutil.ReadFile(chart.Path())
	if err != nil {
		return errors.WithStack(err)
	}
	_, _, err = o.RepositoriesClient.CreateFile(
		ctx,
		o.owner,
		o.repo,
		"charts/"+chartFileName,
		&github.RepositoryContentFileOptions{
			Content: chartContent,
			Message: pointer.StringPtr(fmt.Sprintf(tplCommitMessage, chartFileName)),
			Branch:  pointer.StringPtr(branch),
		},
	)
	return errors.WithStack(err)
}

func (o *gitHubRepositoryManager) destination() string {
	return fmt.Sprintf("github.com/%s/%s@%s", o.owner, o.repo, o.branch)
}
